import argparse
from pathlib import Path
from itertools import chain, combinations
from operator import index
from drive import network
from log import CustomLogger
from xopen import xopen
from drive.network.models import create_indices, FileIndices

logger = CustomLogger.get_logger(__name__)


def generate_indices(ibd_prog_name: str) -> dict[str, str]:
    """function that will generate the correct indices for the IBD program

    Parameters
    ----------
    ibd_prog_name : str
        name of the program that was used to detect pairwise IBD segments

    Returns
    -------
    dict[str, str]
        returns a dictionary that the correct column names for relevant
        column in the IBD files

    Raises
    ------
    ValueError
        raises a value error if the ibd_prog_name is not one of the four
        choices in the match case
    """
    match ibd_prog_name:
        case "germline":
            file_indices = {
                "id1_indx": "column_1",
                "hap1_indx": "column_2",
                "id2_indx": "column_3",
                "hap2_indx": "column_4",
                "chr_indx": "column_5",
                "str_indx": "column_6",
                "end_indx": "column_7",
                "cM_indx": "column_11",
                "unit": "column_12",
            }
        case "ilash":
            file_indices = {
                "id1_indx": "column_1",
                "hap1_indx": "column_2",
                "id2_indx": "column_3",
                "hap2_indx": "column_4",
                "chr_indx": "column_5",
                "str_indx": "column_6",
                "end_indx": "column_7",
                "cM_indx": "column_10",
            }
        case "hapibd":
            file_indices = {
                "id1_indx": "column_1",
                "hap1_indx": "column_2",
                "id2_indx": "column_3",
                "hap2_indx": "column_4",
                "chr_indx": "column_5",
                "str_indx": "column_6",
                "end_indx": "column_7",
                "cM_indx": "column_8",
            }
        case "rapid":
            file_indices = {
                "id1_indx": "column_2",
                "hap1_indx": "column_4",
                "id2_indx": "column_3",
                "hap2_indx": "column_5",
                "chr_indx": "column_1",
                "str_indx": "column_6",
                "end_indx": "column_7",
                "cM_indx": "column_8",
            }
        case _:
            raise ValueError(f"The ibd program, {ibd_prog_name}, was not recognized")

    return file_indices


def load_drive_data(
    drive_results_filepath: Path,
    network_id: str = "",
    pval_threshold: float = None,
    pval_col: str = "",
) -> dict[str, str]:
    """read in the DRIVE results. Filter the networks if the user has
    passed arguments to retrict which networks will be used in the
    analysis

    Parameters
    ----------
    drive_results_filepath : Path
        filepath to a tab separated file generated by the DRIVE cluster
        analysis.

    network_id : str
        ID of a clst in the DRIVE file. We will only return ids for this
        network if the user wishes to filter the data to a specific network.
        There is an assumption that network_id will not be passed to the
        function if pval_threshold is

    pval_threshold : float
        significant threshold that the user can provide. If provided,
        DRIVE will only read in the programs that passed this significance
        threshold. There is an assumption that pval_threshold will not be
        passed to this function if network_id is

    pval_col : str
        column that contains the p-values for each network

    Returns
    -------
    dict[str, str]
        dictionary where the keys are pair ids (Ex: pair1:pair2) and the
        values are the network id they are in

    Raises
    ------
    ValueError
        raises a ValueError if the program can't find the ClstID column or
        the pval_col in the header of the DRIVE file.
    """
    assert (
        not network_id and not pval_threshold
    ), "Values were provided for both the network_id and the pvalue_threshold. Please only provide 1 value"

    return_dict = {}

    with xopen(drive_results_filepath, "r") as results_input:
        header_line = results_input.readline()
        # We need to make sure that certain conditions are met in the
        # header line
        if (
            "clstID" not in header_line
            or pval_col not in header_line
            or "ID.haplotype" not in header_line
        ):
            logger.critical(
                f"The header line does not contain the values that we expected in the file indicating a typo, or the file has either been changed since DRIVE has run, or the file is corrupted. Please verify that the file has the columns, clstID, ID.haplotype, and {pval_col}."
            )
            raise ValueError(
                f"Malformed DRIVE file. Ensure the columns, clstID, ID.haplotype, and {pval_col} are in the file"
            )
        # Pull out the indices that we will need from the header
        split_header = header_line.strip().split("\t")

        clstid_col_indx = split_header.index("clstID")
        pval_col_indx = split_header.index(pval_col)
        haplotype_col_indx = split_header.index("ID.haplotype")

        for line in results_input:
            split_line = line.strip().split("\t")
            clst_id = split_line[clstid_col_indx]
            # We are going to make 2 cases to check the network id or the
            # pvalue threshold. In both cases, we check to see if our
            # comparision term (network_id or pval_threshold) is not None. If
            # it is none then python is smart enough to stop the if statement
            # without evaluating the rest and the code will not break
            if network_id and split_line[clstid_col_indx] != network_id:
                continue
            if pval_threshold and split_line[pval_col_indx] > pval_threshold:
                continue
            # making it here means we either short circuited the if statement
            # or we failed the negative checks
            haplotype_ids = split_line[haplotype_col_indx].split(",")

            haplotype_pairs = chain(
                map(
                    lambda pair_combo: ":".join(pair_combo),
                    combinations(haplotype_ids, 2),
                )
            )

            for value in haplotype_pairs:
                return_dict.update({value: clst_id})

    return return_dict


def pull_network_segments(args: argparse.Namespace) -> None:
    """utilities function that will be used to pull ibd
    segments for the networks of interest"""

    # Lets generate the indices for the correct IBD input
    logger.verbose(f"Gathering file indices for the program, {args.format}")

    ibd_indices = generate_indices(args.format)

    # Read in the drive results file
    drive_mapped_ids = load_drive_data(
        args.drive_results, args.network_id, args.pval_threshold, args.pval_column
    )
